using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Immutable;
using System.Text;

namespace Emotion.SourceGeneration
{
    public static class StructPerMemberHelpersGenerator
    {
        public static void Run(ref SourceProductionContext context, INamedTypeSymbol typ)
        {
            if (!Helpers.HasAttribute(typ.GetAttributes(), "ReflectorGenerateStructPerMemberHelpers"))
                return;

            GeneratePerMemberHelpers(ref context, typ);
        }

        private static void GeneratePerMemberHelpers(ref SourceProductionContext context, INamedTypeSymbol typ)
        {
            string fullTypName = typ.ToDisplayString();
            string safeName = Helpers.GetSafeName(fullTypName);

            ImmutableArray<ISymbol> members = typ.GetMembers();

            StringBuilder sb = new StringBuilder(2000);
            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine("// Generated by Emotion.SourceGeneration");
            sb.AppendLine();
            sb.AppendLine("using System;");
            sb.AppendLine("using System.Collections.Generic;");
            sb.AppendLine("using System.Runtime.CompilerServices;");
            sb.AppendLine("using Emotion.Standard.Reflector;");
            sb.AppendLine("using Emotion.Standard.Reflector.Handlers;");
            sb.AppendLine();

            INamespaceSymbol nameSpace = typ.ContainingNamespace;
            sb.AppendLine($"namespace {nameSpace.ToDisplayString()};");
            sb.AppendLine("");

            sb.AppendLine($"[System.CodeDom.Compiler.GeneratedCode(\"Emotion.SourceGeneration - Reflector\", \"2.0\")]");
            sb.AppendLine($"public partial struct {typ.Name}");

            sb.AppendLine("{");
            sb.AppendLine($"    public readonly bool Equals({typ.Name} other)");
            sb.AppendLine("    {");
            sb.Append("         return ");
            bool first = true;
            foreach (ISymbol member in members)
            {
                if (member.Kind == SymbolKind.Method) continue;
                if (member.IsStatic) continue;
                
                if (!first)
                {
                    sb.Append($" &&\n                ");
                }

                sb.Append($"this.{member.Name} == other.{member.Name}");
                first = false;
            }
            if (first) sb.Append("true");
            sb.Append(";\n");
            sb.AppendLine("    }");

            sb.AppendLine("");

            sb.AppendLine($"    public readonly {typ.Name} Clone()");
            sb.AppendLine("    {");
            sb.AppendLine($"         return new {typ.Name}");
            sb.AppendLine($"         {{");
            foreach (ISymbol member in members)
            {
                if (member.Kind == SymbolKind.Method) continue;
                if (member.IsStatic) continue;

                sb.AppendLine($"             {member.Name} = this.{member.Name},");
            }
            sb.AppendLine("         };");
            sb.AppendLine("    }");
            sb.AppendLine("}");

            context.AddSource($"RFLC.PerMemberHelpers.{safeName}.g.cs", sb.ToString());
        }
    }
}
