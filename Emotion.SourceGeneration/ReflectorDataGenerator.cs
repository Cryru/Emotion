using Microsoft.CodeAnalysis;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using static Emotion.SourceGeneration.Helpers;

namespace SourceGenerator
{
    [Generator]
    public class Generator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            // Collect all the namespaces in the project
            IncrementalValueProvider<IEnumerable<INamespaceSymbol>> namespaceProvider = context.CompilationProvider.Select((compilation, cancellationToken) =>
            {
                var globalNamespace = compilation.GlobalNamespace;
                return globalNamespace.GetNamespaceMembers();
            });

            IncrementalValueProvider<string> entryPointProvider = context.CompilationProvider.Select((compilation, cancellationToken) =>
            {
                var mainMethod = compilation.GetEntryPoint(cancellationToken);
                return mainMethod?.ContainingNamespace.ToDisplayString() ?? (compilation.AssemblyName == "Emotion" ? "Emotion" : "Unknown");
            });
            IncrementalValueProvider<(string Left, IEnumerable<INamespaceSymbol> Right)> combinedProvider = entryPointProvider.Combine(namespaceProvider);

            // Add an incremental step to generate the reflector code for each namespace
            context.RegisterSourceOutput(combinedProvider, (spc, combined) =>
            {
                (string mainNamespace, IEnumerable<INamespaceSymbol> namespaces) = combined;

                var sb = new StringBuilder();
                sb.AppendLine("// <auto-generated/>");
                sb.AppendLine("// Generated by Emotion.SourceGeneration");
                sb.AppendLine();
                sb.AppendLine("using System;");
                sb.AppendLine("using System.Collections.Generic;");
                sb.AppendLine("using System.Runtime.CompilerServices;");
                sb.AppendLine("using Emotion.Standard.Reflector;");
                sb.AppendLine("using Emotion.Standard.Reflector.Handlers;");
                sb.AppendLine();
                sb.AppendLine($"namespace Emotion");
                sb.AppendLine("{");
                sb.AppendLine("   public static class ReflectorData");
                sb.AppendLine("   {");
                sb.AppendLine("");
                sb.AppendLine("       [ModuleInitializer]");
                sb.AppendLine("       public static void Load()");
                sb.AppendLine("       {");
                sb.AppendLine("           ReflectorEngineInit.OnInit += LateLoad;");
                sb.AppendLine("       }");
                sb.AppendLine("");
                sb.AppendLine("       public static void LateLoad()");
                sb.AppendLine("       {");

                foreach (var space in namespaces)
                {
                    GenerateReflectorForNamespace(ref spc, sb, space, mainNamespace);
                }

                sb.AppendLine("       }");
                sb.AppendLine("   }");
                sb.AppendLine("}");

                spc.AddSource("ReflectorData.generated.cs", sb.ToString());
            });
        }

        private static HashSet<string> _excludedNamespacesSubSpaces = new HashSet<string>()
        {
            "Silk",
            "SixLabors",
            "Roslyn",
            "WinApi",
            "FxResources",
            "vc",
            "Microsoft",
            "Accessibility",
            "System",
            "OpenGL",
            "std",
            "<CppImplementationDetails>",
            "<CrtImplementationDetails>",
            "LinqToSqlShared",
            "Emotion.Platform",
            "Emotion.Standard",
            "Emotion.Common",
            "Emotion.Audio",
            "Emotion.Editor",
            "Android",
            "Xamarin",
            "Java",
            "Org"
        };
        private static HashSet<string> _excludedNamespacesTypes = new HashSet<string>()
        {
            "<global namespace>" // Global namespace
        };
        private static HashSet<string> _forceIncludeSubspaces = new HashSet<string>()
        {
            "System.Numerics"
        };

        public static void GenerateReflectorForNamespace(ref SourceProductionContext context, StringBuilder sb, INamespaceSymbol space, string mainNamespace, bool includeTypes = true)
        {
            ImmutableArray<INamedTypeSymbol> types = space.GetTypeMembers();
            string fullSpaceName = space.ToDisplayString();

            bool includeTypesFromNamespace = includeTypes && !_excludedNamespacesTypes.Contains(fullSpaceName);
            bool includeSubSpaces = includeTypes && !_excludedNamespacesSubSpaces.Contains(fullSpaceName) && fullSpaceName[0] != '_';
            if (!includeSubSpaces) includeTypesFromNamespace = false;

            if (mainNamespace == "Emotion" && _forceIncludeSubspaces.Contains(fullSpaceName))
            {
                includeTypesFromNamespace = true;
                includeSubSpaces = true;
            }

            if (includeTypesFromNamespace)
            {
                context.ReportDiagnostic(Diagnostic.Create(new DiagnosticDescriptor(
                   "EMOTION_REFLECT",
                   "Emotion Reflector Generation",
                   $"Generating Reflector for types in namespace - {fullSpaceName}",
                   "Reflection",
                   DiagnosticSeverity.Info,
                   true), Location.None)
                );

                HashSet<INamedTypeSymbol> genericTypesToGenerate = new HashSet<INamedTypeSymbol>(SymbolEqualityComparer.Default);
                foreach (var type in types)
                {
                    GenerateReflectorForType(ref context, sb, type, mainNamespace, genericTypesToGenerate);
                }

                foreach (var type in genericTypesToGenerate)
                {
                    GenerateReflectorForType(ref context, sb, type, mainNamespace, null);
                }
            }

            IEnumerable<INamespaceSymbol> subSpaces = space.GetNamespaceMembers();
            foreach (var subspace in subSpaces)
            {
                GenerateReflectorForNamespace(ref context, sb, subspace, mainNamespace, includeSubSpaces);
            }
        }

        public static void GenerateReflectorForType(ref SourceProductionContext context, StringBuilder sb, INamedTypeSymbol typ, string mainNamespace, HashSet<INamedTypeSymbol> genericTypeSpecifications = null)
        {
            if (!HasParameterlessConstructor(typ)) return;
            if (HasDontSerialize(typ)) return;
            if (typ.IsAbstract) return;
            if (typ.DeclaredAccessibility != Accessibility.Public) return;
            if (typ.IsGenericType && SymbolEqualityComparer.Default.Equals(typ, typ.ConstructedFrom)) return;
            if (typ.IsRefLikeType && typ.IsValueType) return;

            ImmutableArray<AttributeData> classAttributes = typ.GetAttributes();
            if (IsObsolete(classAttributes)) return;

            // Emotion generates its own reflection data, don't generate any for it.
            if (typ.ContainingAssembly.Name == "Emotion" && mainNamespace != "Emotion") return;

            string fullTypName = typ.ToDisplayString();

            Console.WriteLine($"    Generating Reflector for type - {fullTypName}");
            sb.AppendLine($"          ReflectorEngine.RegisterTypeHandler(new ComplexTypeHandler<{fullTypName}>(new ComplexTypeHandlerMember[]");
            sb.AppendLine($"          {{");

            ImmutableArray<ISymbol> members = typ.GetMembers();
            foreach (ISymbol member in members)
            {
                if (member.Kind != SymbolKind.Field && member.Kind != SymbolKind.Property) continue;
                if (member.DeclaredAccessibility != Accessibility.Public) continue;
                if (member.IsStatic) continue;

                ITypeSymbol memberType = null;
                if (member.Kind == SymbolKind.Property && member is IPropertySymbol propSymb)
                {
                    if (propSymb.GetMethod == null || propSymb.SetMethod == null) continue;
                    if (propSymb.GetMethod.DeclaredAccessibility != Accessibility.Public) continue;
                    if (propSymb.SetMethod.DeclaredAccessibility != Accessibility.Public) continue;
                    if (propSymb.SetMethod.IsInitOnly) continue;
                    memberType = propSymb.Type;
                }
                else if (member is IFieldSymbol fieldSymb)
                {
                    if (fieldSymb.IsReadOnly) continue;
                    memberType = fieldSymb.Type;
                }

                string memberName = member.Name;
                if (memberName == "this[]") continue;

                if (genericTypeSpecifications != null && memberType is INamedTypeSymbol namedType && namedType.IsGenericType)
                    genericTypeSpecifications.Add(namedType);

                ImmutableArray<AttributeData> memberAttributes = member.GetAttributes();
                if (IsObsolete(memberAttributes)) continue;

                string memberFullTypeName = memberType?.ToDisplayString();

                // Pointers not supported
                if (memberFullTypeName.Contains("*")) continue;

                // Can't use nullable reference types in a typeof
                if (memberType != null && memberType.IsReferenceType && memberFullTypeName[memberFullTypeName.Length - 1] == '?')
                    memberFullTypeName = memberFullTypeName.Substring(0, memberFullTypeName.Length - 1);
                sb.AppendLine($"              new ComplexTypeHandlerMember<{fullTypName}, {memberFullTypeName}>(\"{memberName}\", (p, v) => p.{memberName} = v, (p) => p.{memberName})");
                sb.AppendLine($"              {{");

                if (memberAttributes.Length > 0)
                {
                    sb.AppendLine($"                  Attributes = new Attribute[] {{");
                    foreach (var attribute in memberAttributes)
                    {
                        var clazz = attribute.AttributeClass;
                        if (clazz.Name != "VertexAttributeAttribute") continue; // todo

                        sb.AppendLine($"                      {GenerateAttributeDeclaration(attribute)},");
                    }
                    sb.AppendLine($"                  }},");
                }

                sb.AppendLine($"              }},");
            }

            sb.AppendLine($"          }}));");
        }
    }
}